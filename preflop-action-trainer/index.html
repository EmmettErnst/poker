<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Preflop Action Trainer</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; background:#0b0f14; color:#e8eef7; }
    .wrap { max-width: 1040px; margin: 0 auto; padding: 24px; }
    h1 { margin: 0 0 8px; font-size: 24px; }
    .muted { opacity:.75; }

    .panel{
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      padding: 16px;
      margin-top: 14px;
    }
    .row { display:flex; gap: 12px; flex-wrap: wrap; align-items: end; }
    label { display:block; font-size: 12px; opacity:.85; margin: 0 0 6px; }

    button, select {
      border-radius: 12px; border: 1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.08); color:#e8eef7;
      padding: 10px 12px; font-size: 14px;
      outline: none;
    }
    button { cursor:pointer; font-weight: 800; }
    button:hover { background: rgba(255,255,255,.12); }
    button:disabled { opacity:.5; cursor:not-allowed; }

    .cardrow { display:flex; gap:16px; margin: 14px 0 8px; align-items:center; flex-wrap: wrap; }
    .playing-card{
      width: 110px; height: 150px; border-radius: 14px;
      background: #f8fbff; color:#111; box-shadow: 0 10px 30px rgba(0,0,0,.35);
      display:flex; flex-direction:column; justify-content:space-between; padding: 10px;
      border: 1px solid rgba(255,255,255,.14);
      user-select:none;
    }
    .corner { font-weight: 800; font-size: 22px; line-height: 1; }
    .suit { font-size: 26px; opacity:.9; }
    .center { display:flex; justify-content:center; align-items:center; font-size: 54px; font-weight: 900; }
    .red { color:#c81d25; }
    .black { color:#111; }

    .actions { display:flex; gap:12px; flex-wrap:wrap; margin-top: 10px; }
    .fold { border-color: rgba(252,165,165,.45); }
    .call { border-color: rgba(147,197,253,.45); }
    .open { border-color: rgba(110,231,183,.45); }
    .raise{ border-color: rgba(251,191,36,.45); }

    .pill{
      display:inline-flex; gap: 8px; align-items:center;
      padding: 8px 10px; border-radius: 999px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.10);
      margin-right: 8px;
      margin-top: 8px;
      font-size: 13px;
    }

    .result { margin-top: 10px; line-height: 1.45; }
    .good { color: #6ee7b7; }
    .ok   { color: #93c5fd; }
    .bad  { color: #fca5a5; }

    .tiny { font-size: 12px; opacity:.8; margin-top: 10px; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; padding: 2px 6px; border-radius: 8px; background: rgba(255,255,255,.10); border: 1px solid rgba(255,255,255,.10); }

    /* --- Table diagram --- */
    .table-diagram{
      display:grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 10px;
      max-width: 720px;
    }
    .seat{
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      border-radius: 14px;
      padding: 10px 10px 8px;
      min-height: 62px;
    }
    .seat .pos{
      font-weight: 900;
      font-size: 13px;
    }
    .seat.you{
      outline: 2px solid rgba(110,231,183,.65);
    }
    .tag{
      margin-top: 6px;
      display:inline-block;
      font-size: 12px;
      opacity: .85;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.06);
    }
    .tag.limp{ border-color: rgba(147,197,253,.45); }
    .tag.raise{ border-color: rgba(251,191,36,.55); }
    .tag.todo{ opacity: .55; }
    .tag.none{ opacity: .45; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Preflop Action Trainer</h1>
    <div class="muted">
      Decide the best preflop action based on position + scenario. Uses your CSV percentiles (lower is better).
    </div>

    <div class="panel">
      <div class="row">
        <div>
          <label for="tableSize">Table</label>
          <select id="tableSize">
            <option value="6" selected>6-max</option>
            <option value="9">9-max</option>
          </select>
        </div>

        <div>
          <label for="difficulty">Difficulty</label>
          <select id="difficulty">
            <option value="easy" selected>Easy (mostly unopened)</option>
            <option value="normal">Normal (unopened + limpers)</option>
            <option value="hard">Hard (adds vs-raise, more borderline)</option>
          </select>
        </div>

        <button id="nextBtn">Next hand</button>
        <button id="resetBtn">Reset stats</button>
      </div>

      <div class="cardrow" id="cardRow"></div>

      <!-- Table diagram -->
      <div class="panel" style="margin-top:14px;">
        <div class="muted" style="margin-bottom:10px;">Table view</div>
        <div id="tableDiagram" class="table-diagram" aria-label="Table diagram"></div>
      </div>

      <div class="actions">
        <button class="fold" id="foldBtn">Fold</button>
        <button class="call" id="callBtn">Call</button>
        <button class="open" id="openBtn">Open</button>
        <button class="raise" id="raiseBtn">Raise</button>
      </div>

      <div class="result" id="result"></div>

      <div>
        <span class="pill">Hand: <b id="handLabel">...</b></span>
        <span class="pill">Position: <b id="posLabel">...</b></span>
        <span class="pill">Scenario: <b id="scenLabel">...</b></span>
        <span class="pill">Orbit: <b id="orbitLabel">...</b></span>
      </div>

      <div>
        <span class="pill">Hands: <b id="handsN">0</b></span>
        <span class="pill">Best: <b id="bestN">0</b></span>
        <span class="pill">Acceptable: <b id="okN">0</b></span>
        <span class="pill">Score: <b id="score">0</b></span>
        <span class="pill">Streak: <b id="streak">0</b></span>
        <span class="pill">Best streak: <b id="bestStreak">0</b></span>
      </div>

      <div class="tiny">
        Shortcuts: <span class="kbd">F</span> fold, <span class="kbd">C</span> call, <span class="kbd">O</span> open, <span class="kbd">R</span> raise, <span class="kbd">N</span> next
      </div>

      <div class="tiny muted" style="margin-top:10px;">
        Scoring: Best = +2, Acceptable = +1, Mistake = 0. Streak counts best-only.
      </div>
    </div>
  </div>

  <script type="module">
    // IMPORTANT:
    // poker/preflop-action-trainer/index.html
    // poker/assets/preflop_rankings_169.js
    import { RANKINGS, buildIndex } from "../assets/preflop_rankings_169.js";
    const { byCards: byHand } = buildIndex(RANKINGS);

    // Orbit positions
    const POSITIONS_6MAX = ["UTG", "HJ", "CO", "BTN", "SB", "BB"];
    const POSITIONS_9MAX = ["UTG", "UTG+1", "UTG+2", "LJ", "HJ", "CO", "BTN", "SB", "BB"];

    // Baseline open cutoffs (percentiles). Lower is better.
    const OPEN_6MAX = {"UTG":18,"HJ":22,"CO":27,"BTN":40,"SB":45,"BB":55};
    const OPEN_9MAX = {"UTG":15,"UTG+1":16,"UTG+2":18,"LJ":20,"HJ":22,"CO":27,"BTN":40,"SB":45,"BB":55};

    function isoCutoff(pos, openCut) {
      if (pos === "BTN") return openCut - 2;
      if (pos === "SB") return openCut - 6;
      if (pos === "BB") return openCut - 10;
      return openCut - 4;
    }
    function limpCallCutoff(pos) {
      if (pos === "BTN") return 34;
      if (pos === "CO")  return 26;
      if (pos === "SB")  return 30;
      if (pos === "BB")  return 38;
      return 0;
    }
    function threeBetCutoff(pos) {
      if (pos === "BTN") return 16;
      if (pos === "CO")  return 14;
      if (pos === "HJ")  return 12;
      if (pos.startsWith("UTG")) return 10;
      if (pos === "LJ") return 11;
      if (pos === "SB") return 14;
      if (pos === "BB") return 0;
      return 12;
    }
    function callVsRaiseCutoff(pos) {
      if (pos === "BTN") return 26;
      if (pos === "CO")  return 20;
      if (pos === "HJ")  return 16;
      if (pos === "SB")  return 20;
      if (pos === "BB")  return 34;
      return 0;
    }

    // Cards
    const RANK_VALUE = new Map([
      ["A",14],["K",13],["Q",12],["J",11],["T",10],
      ["9",9],["8",8],["7",7],["6",6],["5",5],["4",4],["3",3],["2",2]
    ]);
    const SUITS = [
      {c:"♠", color:"black", key:"s"},
      {c:"♥", color:"red",   key:"h"},
      {c:"♦", color:"red",   key:"d"},
      {c:"♣", color:"black", key:"c"},
    ];
    const RANKS = ["A","K","Q","J","T","9","8","7","6","5","4","3","2"];

    function makeDeck() {
      const deck = [];
      for (const r of RANKS) for (const s of SUITS) deck.push({rank:r, suit:s});
      return deck;
    }
    function randInt(n) { return Math.floor(Math.random() * n); }
    function drawTwo() {
      const deck = makeDeck();
      const a = deck.splice(randInt(deck.length), 1)[0];
      const b = deck.splice(randInt(deck.length), 1)[0];
      return [a,b];
    }
    function toHandLabel(c1, c2) {
      const r1 = c1.rank, r2 = c2.rank;
      const v1 = RANK_VALUE.get(r1), v2 = RANK_VALUE.get(r2);
      if (r1 === r2) return r1 + r2;
      let hi = r1, lo = r2;
      if (v2 > v1) { hi = r2; lo = r1; }
      const suited = (c1.suit.key === c2.suit.key);
      return hi + lo + (suited ? "s" : "o");
    }
    function renderCard(card) {
      const isRed = card.suit.color === "red";
      const div = document.createElement("div");
      div.className = "playing-card";

      const top = document.createElement("div");
      top.className = "corner " + (isRed ? "red" : "black");
      top.innerHTML = `${card.rank}<div class="suit">${card.suit.c}</div>`;

      const mid = document.createElement("div");
      mid.className = "center " + (isRed ? "red" : "black");
      mid.textContent = card.suit.c;

      const bot = document.createElement("div");
      bot.className = "corner " + (isRed ? "red" : "black");
      bot.style.transform = "rotate(180deg)";
      bot.innerHTML = `${card.rank}<div class="suit">${card.suit.c}</div>`;

      div.appendChild(top);
      div.appendChild(mid);
      div.appendChild(bot);
      return div;
    }
    function parsePct(x) {
      if (x == null) return NaN;
      const s = String(x).trim().replace("%", "");
      const v = Number(s);
      return Number.isFinite(v) ? v : NaN;
    }

    // UI
    const cardRow = document.getElementById("cardRow");
    const resultEl = document.getElementById("result");
    const handLabelEl = document.getElementById("handLabel");
    const posLabelEl = document.getElementById("posLabel");
    const scenLabelEl = document.getElementById("scenLabel");
    const orbitLabelEl = document.getElementById("orbitLabel");

    const handsNEl = document.getElementById("handsN");
    const bestNEl  = document.getElementById("bestN");
    const okNEl    = document.getElementById("okN");
    const scoreEl  = document.getElementById("score");
    const streakEl = document.getElementById("streak");
    const bestStreakEl = document.getElementById("bestStreak");

    const foldBtn = document.getElementById("foldBtn");
    const callBtn = document.getElementById("callBtn");
    const openBtn = document.getElementById("openBtn");
    const raiseBtn= document.getElementById("raiseBtn");

    const nextBtn = document.getElementById("nextBtn");
    const resetBtn = document.getElementById("resetBtn");
    const tableSizeEl = document.getElementById("tableSize");
    const difficultyEl = document.getElementById("difficulty");

    const tableDiagramEl = document.getElementById("tableDiagram");

    const STORAGE_KEY = "preflop_action_trainer_v1";

    // State
    let positions = POSITIONS_6MAX.slice();
    let openTargets = { ...OPEN_6MAX };
    let orbitIndex = 0;

    let current = null;
    let stats = { hands: 0, best: 0, ok: 0, score: 0, streak: 0, bestStreak: 0 };

    function setStatsUI() {
      handsNEl.textContent = String(stats.hands);
      bestNEl.textContent = String(stats.best);
      okNEl.textContent = String(stats.ok);
      scoreEl.textContent = String(stats.score);
      streakEl.textContent = String(stats.streak);
      bestStreakEl.textContent = String(stats.bestStreak);
    }

    function saveState() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify({
          stats,
          orbitIndex,
          tableSize: Number(tableSizeEl.value),
          difficulty: String(difficultyEl.value || "easy")
        }));
      } catch {}
    }

    function loadState() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return;
        const obj = JSON.parse(raw);
        if (!obj || typeof obj !== "object") return;

        if (obj.stats) stats = { ...stats, ...obj.stats };
        const size = (obj.tableSize === 9) ? 9 : 6;
        tableSizeEl.value = String(size);
        configureTable(size);

        if (typeof obj.difficulty === "string") {
          difficultyEl.value = obj.difficulty;
        }

        if (Number.isFinite(obj.orbitIndex)) {
          orbitIndex = Math.max(0, Math.min(positions.length - 1, obj.orbitIndex));
        }
      } catch {}
    }

    function configureTable(size) {
      if (size === 9) {
        positions = POSITIONS_9MAX.slice();
        openTargets = { ...OPEN_9MAX };
      } else {
        positions = POSITIONS_6MAX.slice();
        openTargets = { ...OPEN_6MAX };
      }
      orbitIndex = 0;
      orbitLabelEl.textContent = `0/${positions.length}`;
    }

    function nextPosition() {
      const pos = positions[orbitIndex];
      orbitIndex = (orbitIndex + 1) % positions.length;
      orbitLabelEl.textContent = `${orbitIndex === 0 ? positions.length : orbitIndex}/${positions.length}`;
      return pos;
    }

    function setActionEnabled(allowed) {
      foldBtn.disabled  = !allowed.includes("fold");
      callBtn.disabled  = !allowed.includes("call");
      openBtn.disabled  = !allowed.includes("open");
      raiseBtn.disabled = !allowed.includes("raise");
    }

    function chooseScenario(difficulty) {
      const r = Math.random();
      if (difficulty === "easy") return (r < 0.80) ? "unopened" : "limpers";
      if (difficulty === "normal") return (r < 0.55) ? "unopened" : "limpers";
      if (r < 0.35) return "unopened";
      if (r < 0.70) return "limpers";
      return "vsRaise";
    }

    function allowedActionsForScenario(scenario) {
      if (scenario === "unopened") return ["fold", "open"];
      if (scenario === "limpers")  return ["fold", "call", "raise"];
      return ["fold", "call", "raise"];
    }

    function decisionForSpot({ pos, scenario, pct, limpers, raiseTo }) {
      const openCut = openTargets[pos] ?? 0;

      if (scenario === "unopened") {
        const shouldOpen = pct <= openCut;
        if (shouldOpen) return { best: ["open"], acceptable: [], note: `Unopened: open if percentile ≤ ${openCut}.` };
        return { best: ["fold"], acceptable: [], note: `Unopened: fold if percentile > ${openCut}.` };
      }

      if (scenario === "limpers") {
        const iso = isoCutoff(pos, openCut);
        const callCut = limpCallCutoff(pos);
        const isoOk = pct <= iso;
        const callOk = pct <= callCut;

        if (isoOk) {
          const acceptable = [];
          if (callOk) acceptable.push("call");
          return { best: ["raise"], acceptable, note: `Limpers (${limpers}): iso-raise if percentile ≤ ${iso}.` };
        }
        if (callOk) return { best: ["call"], acceptable: [], note: `Limpers (${limpers}): call allowed here up to ${callCut}.` };
        return { best: ["fold"], acceptable: [], note: `Limpers (${limpers}): too weak to iso (${iso}) or call (${callCut}).` };
      }

      const tb = threeBetCutoff(pos);
      const cc = callVsRaiseCutoff(pos);

      let callAdj = 0;
      if (pos === "BB" && raiseTo <= 2.5) callAdj = 4;
      const ccAdj = cc + callAdj;

      const can3bet = (tb > 0) && (pct <= tb);
      const canCall = (ccAdj > 0) && (pct <= ccAdj);

      if (can3bet) return { best: ["raise"], acceptable: canCall ? ["call"] : [], note: `Vs raise to ${raiseTo}x: 3-bet if percentile ≤ ${tb}. Call if percentile ≤ ${ccAdj}.` };
      if (canCall) return { best: ["call"], acceptable: [], note: `Vs raise to ${raiseTo}x: call if percentile ≤ ${ccAdj}.` };
      return { best: ["fold"], acceptable: [], note: `Vs raise to ${raiseTo}x: fold outside 3-bet (${tb}) and call (${ccAdj}) ranges.` };
    }

    function prettyScenario(s) {
      if (s === "unopened") return "Unopened pot";
      if (s === "limpers") return "Limpers ahead";
      return "Facing a raise";
    }

    function buildScenarioDetails(scenario) {
      if (scenario === "limpers") {
        const limpers = 1 + randInt(3);
        return { limpers, raiseTo: null };
      }
      if (scenario === "vsRaise") {
        const raiseSizes = [2, 2.2, 2.5, 3];
        const raiseTo = raiseSizes[randInt(raiseSizes.length)];
        return { limpers: null, raiseTo };
      }
      return { limpers: null, raiseTo: null };
    }

    function pickHandNearCutoffIfHard({ difficulty, scenario, pos }) {
      const wantsBorderline = (difficulty === "hard") && (Math.random() < 0.70);
      const maxTries = wantsBorderline ? 80 : 1;

      let best = null;

      const openCut = openTargets[pos] ?? 0;
      let target = openCut;

      if (scenario === "limpers") target = isoCutoff(pos, openCut);
      if (scenario === "vsRaise") {
        const tb = threeBetCutoff(pos);
        const cc = callVsRaiseCutoff(pos);
        target = (tb > 0) ? tb : (cc > 0 ? cc : openCut);
      }

      for (let i = 0; i < maxTries; i++) {
        const cards = drawTwo();
        const label = toHandLabel(cards[0], cards[1]);
        const data = byHand.get(label) || null;
        if (!data) continue;

        const pct = parsePct(data.Percentile);
        if (!Number.isFinite(pct)) continue;

        const cand = { cards, label, data, pct };

        if (!wantsBorderline) return cand;

        const dist = Math.abs(pct - target);
        if (dist <= 5) return cand;

        if (!best || dist < best.dist) best = { ...cand, dist };
      }

      if (best) {
        const { dist, ...rest } = best;
        return rest;
      }

      const cards = drawTwo();
      const label = toHandLabel(cards[0], cards[1]);
      const data = byHand.get(label) || null;
      const pct = data ? parsePct(data.Percentile) : NaN;
      return { cards, label, data, pct };
    }

    /* ---------------- Table diagram rendering ---------------- */

    function renderDiagram({ posList, heroPos, scenario, limpers, raiseTo }) {
      if (!tableDiagramEl) return;

      const ordered = posList.slice();
      const heroIndex = ordered.indexOf(heroPos);
      const ahead = heroIndex > 0 ? ordered.slice(0, heroIndex) : [];
      const behind = heroIndex >= 0 ? ordered.slice(heroIndex + 1) : [];

      const tagsByPos = new Map();

      if (scenario === "unopened") {
        // no tags ahead
      } else if (scenario === "limpers") {
        const n = Math.min(Number(limpers || 0), ahead.length);
        const limpersAhead = ahead.slice(-n);
        for (const p of limpersAhead) {
          tagsByPos.set(p, { text: "Limp", cls: "limp" });
        }
      } else if (scenario === "vsRaise") {
        if (ahead.length > 0) {
          const raiser = ahead[ahead.length - 1];
          tagsByPos.set(raiser, { text: `Raise ${raiseTo}x`, cls: "raise" });
        }
      }

      for (const p of behind) {
        if (!tagsByPos.has(p)) tagsByPos.set(p, { text: "To act", cls: "todo" });
      }

      tableDiagramEl.innerHTML = "";
      for (const p of ordered) {
        const seat = document.createElement("div");
        seat.className = "seat" + (p === heroPos ? " you" : "");

        const top = document.createElement("div");
        top.className = "pos";
        top.textContent = p;
        seat.appendChild(top);

        if (p === heroPos) {
          const t = document.createElement("div");
          t.className = "tag";
          t.textContent = "YOU";
          seat.appendChild(t);
        }

        const tag = tagsByPos.get(p);
        if (tag) {
          const t = document.createElement("div");
          t.className = `tag ${tag.cls}`;
          t.textContent = tag.text;
          seat.appendChild(t);
        } else if (p !== heroPos) {
          const t = document.createElement("div");
          t.className = "tag none";
          t.textContent = "—";
          seat.appendChild(t);
        }

        tableDiagramEl.appendChild(seat);
      }
    }

    /* ---------------- Main loop ---------------- */

    function newHand() {
      resultEl.innerHTML = "";
      cardRow.innerHTML = "";

      const pos = nextPosition();
      const difficulty = String(difficultyEl.value || "easy");
      const scenario = chooseScenario(difficulty);
      const details = buildScenarioDetails(scenario);

      const pick = pickHandNearCutoffIfHard({ difficulty, scenario, pos });
      const { cards, label, data, pct } = pick;

      cardRow.appendChild(renderCard(cards[0]));
      cardRow.appendChild(renderCard(cards[1]));

      handLabelEl.textContent = label + (data ? "" : " (not found)");
      posLabelEl.textContent = pos;
      scenLabelEl.textContent = prettyScenario(scenario);

      const allowed = allowedActionsForScenario(scenario);
      setActionEnabled(allowed);

      renderDiagram({
        posList: positions,
        heroPos: pos,
        scenario,
        limpers: details.limpers,
        raiseTo: details.raiseTo
      });

      if (!data || !Number.isFinite(pct)) {
        current = { label, data, pct, pos, scenario, ...details, allowed, answers: null, answered: true };
        setActionEnabled([]);
        resultEl.innerHTML = `<div class="bad">Hand data missing for <b>${label}</b>. Try Next.</div>`;
        saveState();
        return;
      }

      const answers = decisionForSpot({
        pos, scenario, pct,
        limpers: details.limpers,
        raiseTo: details.raiseTo ?? 0
      });

      current = {
        cards, label, data, pct,
        pos, scenario,
        limpers: details.limpers,
        raiseTo: details.raiseTo,
        allowed,
        answers,
        answered: false
      };

      let hint = "";
      if (scenario === "limpers") hint = `Limpers: <b>${current.limpers}</b>`;
      if (scenario === "vsRaise") hint = `Raise to: <b>${current.raiseTo}x</b>`;
      if (hint) resultEl.innerHTML = `<div class="muted">${hint}</div>`;

      saveState();
    }

    function grade(choice) {
      if (!current || current.answered) return;
      if (!current.allowed.includes(choice)) return;

      current.answered = true;
      setActionEnabled([]);

      const { best, acceptable, note } = current.answers;

      let tier = "bad";
      let points = 0;

      if (best.includes(choice)) {
        tier = "good";
        points = 2;
        stats.best += 1;
        stats.streak += 1;
        if (stats.streak > stats.bestStreak) stats.bestStreak = stats.streak;
      } else if (acceptable.includes(choice)) {
        tier = "ok";
        points = 1;
        stats.ok += 1;
        stats.streak = 0;
      } else {
        tier = "bad";
        points = 0;
        stats.streak = 0;
      }

      stats.hands += 1;
      stats.score += points;

      setStatsUI();
      saveState();

      const pctRounded = Math.round(current.pct);
      const bestText = best.map(x => x.toUpperCase()).join(" / ");
      const okText = acceptable.length ? acceptable.map(x => x.toUpperCase()).join(" / ") : "None";

      let spotLine = "";
      if (current.scenario === "limpers") spotLine = `Limpers: <b>${current.limpers}</b>`;
      if (current.scenario === "vsRaise") spotLine = `Facing raise to <b>${current.raiseTo}x</b>`;

      resultEl.innerHTML = `
        <div class="${tier}">
          You chose <b>${choice.toUpperCase()}</b>. Best: <b>${bestText}</b>. Points: <b>+${points}</b>.
        </div>
        <div class="muted" style="margin-top:6px;">
          ${spotLine ? spotLine + " | " : ""}Hand percentile: <b>${pctRounded}</b> (lower is stronger)
        </div>
        <div class="muted" style="margin-top:6px;">
          Acceptable: <b>${okText}</b>
        </div>
        <div class="muted" style="margin-top:6px;">
          ${note}
        </div>
        <div class="muted" style="margin-top:6px;">
          Rank: <b>#${current.data.Rank}</b> | Win: <b>${current.data["% win"]}</b> | Tie: <b>${current.data["% tie"]}</b>
        </div>
      `;
    }

    function resetStats() {
      stats = { hands: 0, best: 0, ok: 0, score: 0, streak: 0, bestStreak: 0 };
      setStatsUI();
      resultEl.innerHTML = "";
      saveState();
    }

    // Events
    foldBtn.addEventListener("click", () => grade("fold"));
    callBtn.addEventListener("click", () => grade("call"));
    openBtn.addEventListener("click", () => grade("open"));
    raiseBtn.addEventListener("click", () => grade("raise"));

    nextBtn.addEventListener("click", newHand);
    resetBtn.addEventListener("click", resetStats);

    tableSizeEl.addEventListener("change", () => {
      const size = Number(tableSizeEl.value) === 9 ? 9 : 6;
      configureTable(size);
      saveState();
      newHand();
    });

    difficultyEl.addEventListener("change", () => {
      saveState();
      newHand();
    });

    document.addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      if (k === "n") newHand();
      if (k === "f") grade("fold");
      if (k === "c") grade("call");
      if (k === "o") grade("open");
      if (k === "r") grade("raise");
    });

    // Init
    configureTable(6);
    loadState();
    setStatsUI();
    newHand();
  </script>
</body>
</html>
